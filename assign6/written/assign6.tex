\documentclass[11pt]{article}

\input{../../tex/defs.tex}

\newcommand{\lfun}[3]{\text{\textexclamdown}\lambda~{#1}:{#2}~.~{#3}}
\newcommand{\lapp}[2]{\text{\textexclamdown}{#1}~{#2}}
\newcommand{\lprim}[2]{\text{\textexclamdown}{#1}~{#2}}
\newcommand{\lcase}[2]{\mathsf{case}~{#1}~\mathsf{of}~{#2}}
\newcommand{\ltyprim}[1]{\text{\textexclamdown}\msf{#1}}
\newcommand{\ltyfun}[2]{{#1} \multimap {#2}}
\newcommand{\sconcat}[2]{{#1} {}^\wedge {#2}}
\newcommand{\sreturn}[1]{\msf{return}~{#1}}
\newcommand{\validJ}[2]{{#1} \vdash {#2} ~ \msf{valid}}
\newcommand{\validJC}[1]{\ctx \vdash {#1} ~ \msf{valid}}

\begin{document}

\hwtitle
  {Assignment 6}
  {Vivek Pandya (vpandya)} %% REPLACE THIS WITH YOUR NAME/ID

\problem{Problem 1.1}

\begin{enumerate}
\item % Your answer to 1.1.1 here
Since linear type enforces ``No duplication'' and ``No discarding'' behaviour, all the changes done one the world will be actaully performed on the world by overwriting yhe value. However in PL with out liner type it requires duplication and discrad operations to get desired changes in the world. I.e changes won't be applied on existing world but new copy with desired changes will be created and old will be discarded.
\item
  \begin{enumerate} % Your answers to 1.1.2 here
    \item $${\ltyfun{\ltyprim{Bool}}{\ltyprim{Bool}}}$$
    \item $${\ltyfun{\ltyprim{Bool}}{\ltyprim{Bool}}}$$
    \item Can't have type because in case statement x has type K then it can not be used again as some vlaue v with type V. 
    \item $${\ltyfun{\ltyfun{\ltyprim{List}}{(\ltyfun{\ltyprim{Val}}{\ltyprim{Val}})}}{\ltyprim{List}}}$$
  \end{enumerate}
\end{enumerate}

% Here's some examples of Latexing with Wadler's linear types.
% DELETE THESE BEFORE SUBMITTING
\begin{align*}

\end{align*}

\end{document}
